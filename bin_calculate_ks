bin_calculate_ks <- function(data, binSize = 1, imageVolume, rev = FALSE) {
  #' Get bin averages for VPR and CTD data
  #'
  #' Bins CTD data for an individual cast to avoid depth averaging across tow-yo's
  #'
  #' @author E. Chisholm, K. Sorochan
  #'
  #'

  #' @param data ctd data frame object including scan, salinity, temperature,
  #'   depth, conductivity, time, fluor_ref, turbidity_ref, turbidity_mv,
  #'   altitude, cast_id, n_roi
  #' @param binSize the height of bins over which to average, default is 1 metre
  #' @param imageVolume the volume of VPR images used for calculating concentrations (mm^3)
  #' @param rev logical value, if TRUE, binning will begin at bottom of each cast,
  #'   this controls data loss due to uneven binning over depth. If bins begin at
  #'   bottom, small amounts of data may be lost at the surface of each cast, if
  #'   binning begins at surface (rev = FALSE), small amounts of data may be lost
  #'   at bottom of each cast
  #'
  #'
  #' @details Image volume calculations can change based on optical setting of VPR as well as autodeck setting used to process images
  #' For IML2018051 (S2) image volume was calculated as 108155 mm^3 by seascan (6.6 cubic inches)
  #' For COR2019002 S2 image volume was calculated as 83663 mm^3 and S3 image volume was calculated as 366082 mm^3.
  #' Used internally ( \code{\link{bin_cast}} ) after \code{\link{ctd_cast}} on a single ascending or descending section of VPR cast
  #'
  #'
  #'
  #' @note binSize should be carefully considered for best results
  #' @note Depth is used for calculations! Please ensure depth is included in data frame using \link[oce]{swDepth}
  #'
  #' @export
  #'
  # input validation
  # Check that the data argument is a data frame
  if (!is.data.frame(data)) {
    stop("data must be a data frame")
  }

  # Check that the binSize argument is a numeric value greater than 0
  if (!is.numeric(binSize) || binSize <= 0) {
    stop("binSize must be a numeric value greater than 0")
  }

  # Check that the imageVolume argument is a numeric value greater than 0
  if (!is.numeric(imageVolume) || imageVolume <= 0) {
    stop("imageVolume must be a numeric value greater than 0")
  }

  # Check that the rev argument is a logical value
  if (!is.logical(rev)) {
    stop("rev must be a logical value")
  }

  cn <- colnames(data)

  # Check that the data argument has a "depth" column
  if (!"depth" %in% cn) {
    stop("data must have a 'depth' column")
  }

  # Check that the data argument has a "cast_id" column
  if (!"cast_id" %in% cn) {
    stop("data must have a 'cast_id' column")
  }

  # Check that the data argument has an "n_roi" column
  if (!"n_roi" %in% cn) {
    stop("data must have an 'n_roi' column")
  }

  # Check that the data argument has a "cast_id" column
  if (!"time_ms" %in% cn) {
    stop("data must have a 'time_ms' column")
  }

  cast_id <- unique(data$cast_id)
  max_cast_depth <- max(data$depth) # ADDED BY KS TO IDENTIFY EACH TOWYO CHUNK

  p <- data$depth
  max_depth <- max(p, na.rm = TRUE)
  min_depth <- min(p, na.rm = TRUE)

  x_breaks <- seq(from = floor(min_depth), to = ceiling(max_depth), by = binSize)

  if (rev == TRUE) {
    x_breaks <- seq(from = ceiling(max_depth), to = floor(min_depth), by = - binSize) #reversed by KS
  }

  # error when cast is too small
  if (max_depth - min_depth < binSize) {
    warning(paste('Cast', cast_id, 'is too small to calculate information for bins of size', binSize))
    data.frame(NULL)
  } else {


    # Get variables of interest using oce bin functions

    min_time_s <- oce::binApply1D(p, data$time_ms / 1000, xbreaks = x_breaks, min)$result
    max_time_s <- oce::binApply1D(p, data$time_ms / 1000, xbreaks = x_breaks, max)$result
    min_depth <- oce::binApply1D(p, data$depth, xbreaks = x_breaks, min)$result
    max_depth <- oce::binApply1D(p, data$depth, xbreaks = x_breaks, max)$result
    n_roi_bin <- oce::binApply1D(p, data$n_roi, xbreaks = x_breaks, sum)$result
    time_ms <- oce::binApply1D(p, data$time_ms, xbreaks = x_breaks, mean)$result
    time_hr <- oce::binApply1D(p, data$time_ms / (1000 * 3600), xbreaks = x_breaks, mean)$result # update time naming scheme May 2022

    env1 <- data %>%
      dplyr::select(., is.numeric) %>%
      dplyr::select(., -n_roi, -depth)

    env2 <- data.frame(lapply(env1, function(x) {oce::binApply1D(p, x, x_breaks, mean)$result}))

    # temperature <- oce::binApply1D(p, data$temperature, xbreaks = x_breaks, mean)$result
    # salinity <- oce::binApply1D(p, data$salinity, xbreaks = x_breaks, mean)$result
    # density <- oce::binApply1D(p, data$sigmaT, xbreaks = x_breaks, mean)$result
    # fluorescence <- oce::binApply1D(p, data$fluorescence_mv, xbreaks = x_breaks, mean)$result
    # turbidity <- oce::binApply1D(p, data$turbidity_mv, xbreaks = x_breaks, mean)$result

    if (rev == TRUE) {

      depth <- rev(oce::binApply1D(p, data$depth, xbreaks = x_breaks, mean)$xmids)

    } else { # simplify?

      depth <- oce::binApply1D(p, data$time_ms, xbreaks = x_breaks, mean)$xmids

    }
    # calculates number of frames captured per depth bin by counting number of pressure observations per bin
    n_frames <- oce::binApply1D(p, data$depth, xbreaks = x_breaks, length)$result # KS edit 10/9/19

    # WARNING
    # binApply1D does not calculate NAs, if there is binned depth range that does
    # not contain any data, the binApply function will not create an empty or NA
    # placeholder bin in that case the result length will be different than the
    # length of midpoints since the variable "pressure" is a mid point calculation it is used to
    # test for non existent empty bins. If there are non existent empty bins,
    # binMean1D will calculate them as NA, this loop finds where the bins would
    # have been located and removes those indexes from the pressure vector so the
    # length of variables is all identical

    if (!(length(depth) == length(time_ms))) {

      test_mean <- binMean1D(p, data$time_ms, xbreaks = x_breaks)$result

      idx_rm <- which(is.na(test_mean))

      # informs user where bins were removed due to NAs
      # note if a bin is 'NA' typically because there is no valid data in that depth range,
      # if you have a lot of NA bins, think about increasing your binSize
      message(paste('Removed bins at', depth[idx_rm]))

      lp <- length(depth)
      depth <- depth[-idx_rm]
      if (length(n_frames) == lp) {
        n_frames <- n_frames[-idx_rm]
      }

    }
    # make sure n_frames matches the length of other data frame rows
    if (length(n_frames) > length(depth)) {
      n_frames <- n_frames[-length(n_frames)]
    }
    if (length(n_frames) < length(depth)) {
      n_frames <- c(n_frames, 0)
    }
    if (length(n_frames) != length(depth)) {
      length(n_frames) <- length(depth)
    }
    # Get derived variables

    time_diff_s <- max_time_s - min_time_s

    # calculate concentration
    vol_sampled_bin_m3 <- (imageVolume / 1e09) * n_frames
    conc_m3 <- n_roi_bin / (vol_sampled_bin_m3) # KS 10/9/19

    depth_diff <- max_depth - min_depth

    # Output
    # data.frame(depth, min_depth, max_depth, depth_diff, min_time_s, max_time_s, time_diff_s,
    #            n_roi_bin, conc_m3,
    #            temperature, salinity, density, fluorescence, turbidity,
    #            time_hr, n_frames, vol_sampled_bin_m3, time_ms,
    #            towyo = cast_id, max_cast_depth)

    data.frame(time_ms, time_hr, towyo = cast_id, depth, min_depth, max_depth, depth_diff, min_time_s, max_time_s, time_diff_s, n_roi_bin, conc_m3, n_frames,
               vol_sampled_bin_m3, max_cast_depth, env2)


    # MAX CAST PRESSURE ADDED BY KS
  } # end else loop for size error
}
